/* Generated by Nimrod Compiler v0.9.5 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <sys/mman.h>

#include <sys/types.h>

#include <string.h>

#include <fcntl.h>

#include <sys/stat.h>

#include <unistd.h>

#include <sys/time.h>
typedef struct tmemfile238204 tmemfile238204;
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
struct  tmemfile238204  {
void* Mem;
NI Size;
int Handle;
};
typedef N_NIMCALL_PTR(void, TY2289) (void* p, NI op);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY2289 marker;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
N_NIMCALL(void*, mapmem_238210)(tmemfile238204* m, NU8 mode, NI mappedsize, NI offset);
N_NIMCALL(void, failedassertimpl_80621)(NimStringDesc* msg);
N_NIMCALL(void, oserror_107405)(NI32 errorcode);
N_NIMCALL(NI32, oslasterror_107431)(void);
static N_INLINE(void, nimFrame)(TFrame* s);
static N_INLINE(void, popFrame)(void);
N_NIMCALL(void, unmapmem_238605)(tmemfile238204* f, void* p, NI size);
N_NIMCALL(tmemfile238204, open_238803)(NimStringDesc* filename, NU8 mode, NI mappedsize, NI offset, NI newfilesize);
N_NIMCALL(void, close_239245)(tmemfile238204* f);
STRING_LITERAL(TMP2955, "mappedSize > 0 ", 15);
STRING_LITERAL(TMP2956, "newFileSize == - 1 or mode != fmRead ", 37);
extern TFrame* frameptr_13438;
TNimType NTI238204; /* TMemFile */
extern TNimType NTI147; /* pointer */
extern TNimType NTI106; /* int */
extern TNimType NTI4409; /* cint */

static N_INLINE(void, nimFrame)(TFrame* s) {
	(*s).prev = frameptr_13438;
	frameptr_13438 = s;
}

static N_INLINE(void, popFrame)(void) {
	frameptr_13438 = (*frameptr_13438).prev;
}

N_NIMCALL(void*, mapmem_238210)(tmemfile238204* m, NU8 mode, NI mappedsize, NI offset) {
	void* result;
	NIM_BOOL readonly;
	int LOC5;
	int LOC11;
	nimfr("mapMem", "memfiles.nim")
	result = 0;
	nimln(40, "memfiles.nim");
	nimln(40, "memfiles.nim");
	readonly = (mode == ((NU8) 0));
	nimln(52, "memfiles.nim");
	{
		nimln(52, "memfiles.nim");
		nimln(52, "memfiles.nim");
		if (!!((0 < mappedsize))) goto LA3;
		nimln(52, "memfiles.nim");
		failedassertimpl_80621(((NimStringDesc*) &TMP2955));
	}
	LA3: ;
	nimln(53, "memfiles.nim");
	LOC5 = 0;
	nimln(56, "memfiles.nim");
	{
		if (!readonly) goto LA8;
		LOC5 = PROT_READ;
	}
	goto LA6;
	LA8: ;
	{
		nimln(56, "memfiles.nim");
		LOC5 = (NI32)(PROT_READ | PROT_WRITE);
	}
	LA6: ;
	LOC11 = 0;
	nimln(57, "memfiles.nim");
	{
		if (!readonly) goto LA14;
		LOC11 = MAP_PRIVATE;
	}
	goto LA12;
	LA14: ;
	{
		LOC11 = MAP_SHARED;
	}
	LA12: ;
	result = mmap(NIM_NIL, mappedsize, LOC5, LOC11, (*m).Handle, ((off_t) (offset)));
	nimln(59, "memfiles.nim");
	{
		NI32 LOC21;
		nimln(59, "memfiles.nim");
		if (!(result == ((void*) (MAP_FAILED)))) goto LA19;
		nimln(60, "memfiles.nim");
		nimln(60, "memfiles.nim");
		LOC21 = 0;
		LOC21 = oslasterror_107431();
		oserror_107405(LOC21);
	}
	LA19: ;
	popFrame();
	return result;
}

N_NIMCALL(void, unmapmem_238605)(tmemfile238204* f, void* p, NI size) {
	nimfr("unmapMem", "memfiles.nim")
	nimln(71, "memfiles.nim");
	{
		int LOC3;
		NI32 LOC6;
		nimln(71, "memfiles.nim");
		nimln(71, "memfiles.nim");
		nimln(71, "memfiles.nim");
		LOC3 = 0;
		LOC3 = munmap(p, size);
		if (!!((LOC3 == ((NI32) 0)))) goto LA4;
		nimln(71, "memfiles.nim");
		nimln(71, "memfiles.nim");
		LOC6 = 0;
		LOC6 = oslasterror_107431();
		oserror_107405(LOC6);
	}
	LA4: ;
	popFrame();
}

N_NIMCALL(tmemfile238204, open_238803)(NimStringDesc* filename, NU8 mode, NI mappedsize, NI offset, NI newfilesize) {
	tmemfile238204 result;
	NIM_BOOL readonly;
	int flags;
	int LOC59;
	int LOC65;
	nimfr("open", "memfiles.nim")
	memset((void*)&result, 0, sizeof(result));
	nimln(95, "memfiles.nim");
	{
		NIM_BOOL LOC3;
		nimln(95, "memfiles.nim");
		nimln(95, "memfiles.nim");
		LOC3 = 0;
		nimln(95, "memfiles.nim");
		LOC3 = (newfilesize == -1);
		if (LOC3) goto LA4;
		nimln(95, "memfiles.nim");
		nimln(95, "memfiles.nim");
		LOC3 = !((mode == ((NU8) 0)));
		LA4: ;
		if (!!(LOC3)) goto LA5;
		nimln(95, "memfiles.nim");
		failedassertimpl_80621(((NimStringDesc*) &TMP2956));
	}
	LA5: ;
	nimln(96, "memfiles.nim");
	nimln(96, "memfiles.nim");
	readonly = (mode == ((NU8) 0));
	nimln(177, "memfiles.nim");
	nimln(177, "memfiles.nim");
	{
		if (!readonly) goto LA9;
		flags = O_RDONLY;
	}
	goto LA7;
	LA9: ;
	{
		flags = O_RDWR;
	}
	LA7: ;
	nimln(179, "memfiles.nim");
	{
		NI32 permissionsmode;
		nimln(179, "memfiles.nim");
		nimln(179, "memfiles.nim");
		if (!!((newfilesize == -1))) goto LA14;
		nimln(180, "memfiles.nim");
		nimln(180, "memfiles.nim");
		nimln(180, "memfiles.nim");
		flags = (NI32)((NI32)(flags | O_CREAT) | O_TRUNC);
		nimln(181, "memfiles.nim");
		nimln(181, "memfiles.nim");
		permissionsmode = (NI32)(S_IRUSR | S_IWUSR);
		nimln(182, "memfiles.nim");
		result.Handle = open(filename->data, flags, permissionsmode);
	}
	goto LA12;
	LA14: ;
	{
		nimln(184, "memfiles.nim");
		result.Handle = open(filename->data, flags);
	}
	LA12: ;
	nimln(186, "memfiles.nim");
	{
		NI32 LOC26;
		nimln(186, "memfiles.nim");
		if (!(result.Handle == ((NI32) -1))) goto LA19;
		nimln(99, "memfiles.nim");
		result.Mem = NIM_NIL;
		nimln(100, "memfiles.nim");
		result.Size = 0;
		nimln(174, "memfiles.nim");
		{
			int LOC25;
			nimln(174, "memfiles.nim");
			nimln(174, "memfiles.nim");
			if (!!((result.Handle == ((NI32) 0)))) goto LA23;
			nimln(174, "memfiles.nim");
			nimln(174, "memfiles.nim");
			LOC25 = 0;
			LOC25 = close(result.Handle);
		}
		LA23: ;
		nimln(175, "memfiles.nim");
		nimln(189, "memfiles.nim");
		LOC26 = 0;
		LOC26 = oslasterror_107431();
		oserror_107405(LOC26);
	}
	LA19: ;
	nimln(191, "memfiles.nim");
	{
		nimln(191, "memfiles.nim");
		nimln(191, "memfiles.nim");
		if (!!((newfilesize == -1))) goto LA29;
		nimln(192, "memfiles.nim");
		{
			int LOC33;
			NI32 LOC41;
			nimln(192, "memfiles.nim");
			nimln(192, "memfiles.nim");
			LOC33 = 0;
			LOC33 = ftruncate(result.Handle, ((off_t) (newfilesize)));
			if (!(LOC33 == ((NI32) -1))) goto LA34;
			nimln(99, "memfiles.nim");
			result.Mem = NIM_NIL;
			nimln(100, "memfiles.nim");
			result.Size = 0;
			nimln(174, "memfiles.nim");
			{
				int LOC40;
				nimln(174, "memfiles.nim");
				nimln(174, "memfiles.nim");
				if (!!((result.Handle == ((NI32) 0)))) goto LA38;
				nimln(174, "memfiles.nim");
				nimln(174, "memfiles.nim");
				LOC40 = 0;
				LOC40 = close(result.Handle);
			}
			LA38: ;
			nimln(175, "memfiles.nim");
			nimln(193, "memfiles.nim");
			LOC41 = 0;
			LOC41 = oslasterror_107431();
			oserror_107405(LOC41);
		}
		LA34: ;
	}
	LA29: ;
	nimln(195, "memfiles.nim");
	{
		nimln(195, "memfiles.nim");
		nimln(195, "memfiles.nim");
		if (!!((mappedsize == -1))) goto LA44;
		nimln(196, "memfiles.nim");
		result.Size = mappedsize;
	}
	goto LA42;
	LA44: ;
	{
		struct stat stat;
		memset((void*)&stat, 0, sizeof(stat));
		nimln(199, "memfiles.nim");
		{
			int LOC49;
			nimln(199, "memfiles.nim");
			nimln(199, "memfiles.nim");
			nimln(199, "memfiles.nim");
			LOC49 = 0;
			LOC49 = fstat(result.Handle, &stat);
			if (!!((LOC49 == ((NI32) -1)))) goto LA50;
			nimln(202, "memfiles.nim");
			result.Size = ((NI) (stat.st_size));
		}
		goto LA47;
		LA50: ;
		{
			NI32 LOC58;
			nimln(99, "memfiles.nim");
			result.Mem = NIM_NIL;
			nimln(100, "memfiles.nim");
			result.Size = 0;
			nimln(174, "memfiles.nim");
			{
				int LOC57;
				nimln(174, "memfiles.nim");
				nimln(174, "memfiles.nim");
				if (!!((result.Handle == ((NI32) 0)))) goto LA55;
				nimln(174, "memfiles.nim");
				nimln(174, "memfiles.nim");
				LOC57 = 0;
				LOC57 = close(result.Handle);
			}
			LA55: ;
			nimln(175, "memfiles.nim");
			nimln(204, "memfiles.nim");
			LOC58 = 0;
			LOC58 = oslasterror_107431();
			oserror_107405(LOC58);
		}
		LA47: ;
	}
	LA42: ;
	nimln(206, "memfiles.nim");
	LOC59 = 0;
	nimln(209, "memfiles.nim");
	{
		if (!readonly) goto LA62;
		LOC59 = PROT_READ;
	}
	goto LA60;
	LA62: ;
	{
		nimln(209, "memfiles.nim");
		LOC59 = (NI32)(PROT_READ | PROT_WRITE);
	}
	LA60: ;
	LOC65 = 0;
	nimln(210, "memfiles.nim");
	{
		if (!readonly) goto LA68;
		LOC65 = MAP_PRIVATE;
	}
	goto LA66;
	LA68: ;
	{
		LOC65 = MAP_SHARED;
	}
	LA66: ;
	result.Mem = mmap(NIM_NIL, result.Size, LOC59, LOC65, result.Handle, ((off_t) (offset)));
	nimln(214, "memfiles.nim");
	{
		NI32 LOC80;
		nimln(214, "memfiles.nim");
		if (!(result.Mem == ((void*) (MAP_FAILED)))) goto LA73;
		nimln(99, "memfiles.nim");
		result.Mem = NIM_NIL;
		nimln(100, "memfiles.nim");
		result.Size = 0;
		nimln(174, "memfiles.nim");
		{
			int LOC79;
			nimln(174, "memfiles.nim");
			nimln(174, "memfiles.nim");
			if (!!((result.Handle == ((NI32) 0)))) goto LA77;
			nimln(174, "memfiles.nim");
			nimln(174, "memfiles.nim");
			LOC79 = 0;
			LOC79 = close(result.Handle);
		}
		LA77: ;
		nimln(175, "memfiles.nim");
		nimln(215, "memfiles.nim");
		LOC80 = 0;
		LOC80 = oslasterror_107431();
		oserror_107405(LOC80);
	}
	LA73: ;
	popFrame();
	return result;
}

N_NIMCALL(void, close_239245)(tmemfile238204* f) {
	NIM_BOOL error;
	NI32 lasterr;
	nimfr("close", "memfiles.nim")
	nimln(221, "memfiles.nim");
	error = NIM_FALSE;
	lasterr = 0;
	nimln(231, "memfiles.nim");
	{
		int LOC5;
		NIM_BOOL LOC6;
		int LOC7;
		nimln(231, "memfiles.nim");
		nimln(231, "memfiles.nim");
		if (!!(((*f).Handle == ((NI32) 0)))) goto LA3;
		nimln(232, "memfiles.nim");
		nimln(232, "memfiles.nim");
		nimln(232, "memfiles.nim");
		nimln(232, "memfiles.nim");
		LOC5 = 0;
		LOC5 = munmap((*f).Mem, (*f).Size);
		error = !((LOC5 == ((NI32) 0)));
		nimln(233, "memfiles.nim");
		lasterr = oslasterror_107431();
		nimln(234, "memfiles.nim");
		nimln(234, "memfiles.nim");
		LOC6 = 0;
		nimln(234, "memfiles.nim");
		nimln(234, "memfiles.nim");
		nimln(234, "memfiles.nim");
		LOC7 = 0;
		LOC7 = close((*f).Handle);
		LOC6 = !((LOC7 == ((NI32) 0)));
		if (LOC6) goto LA8;
		LOC6 = error;
		LA8: ;
		error = LOC6;
	}
	LA3: ;
	nimln(236, "memfiles.nim");
	(*f).Size = 0;
	nimln(237, "memfiles.nim");
	(*f).Mem = NIM_NIL;
	nimln(243, "memfiles.nim");
	(*f).Handle = ((int) 0);
	nimln(245, "memfiles.nim");
	{
		if (!error) goto LA11;
		nimln(245, "memfiles.nim");
		oserror_107405(lasterr);
	}
	LA11: ;
	popFrame();
}
N_NOINLINE(void, stdlibmemfilesInit)(void) {
	nimfr("memfiles", "memfiles.nim")
	popFrame();
}

N_NOINLINE(void, stdlibmemfilesDatInit)(void) {
static TNimNode* TMP3037[3];
static TNimNode TMP2953[4];
NTI238204.size = sizeof(tmemfile238204);
NTI238204.kind = 18;
NTI238204.base = 0;
NTI238204.flags = 3;
TMP3037[0] = &TMP2953[1];
TMP2953[1].kind = 1;
TMP2953[1].offset = offsetof(tmemfile238204, Mem);
TMP2953[1].typ = (&NTI147);
TMP2953[1].name = "mem";
TMP3037[1] = &TMP2953[2];
TMP2953[2].kind = 1;
TMP2953[2].offset = offsetof(tmemfile238204, Size);
TMP2953[2].typ = (&NTI106);
TMP2953[2].name = "size";
TMP3037[2] = &TMP2953[3];
TMP2953[3].kind = 1;
TMP2953[3].offset = offsetof(tmemfile238204, Handle);
TMP2953[3].typ = (&NTI4409);
TMP2953[3].name = "handle";
TMP2953[0].len = 3; TMP2953[0].kind = 2; TMP2953[0].sons = &TMP3037[0];
NTI238204.node = &TMP2953[0];
}

